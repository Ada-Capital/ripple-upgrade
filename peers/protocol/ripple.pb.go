// Code generated by protoc-gen-go.
// source: ripple.proto
// DO NOT EDIT!

package protocol

import proto "code.google.com/p/goprotobuf/proto"
import json "encoding/json"
import math "math"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

type MessageType int32

const (
	// core
	MessageType_mtHELLO       MessageType = 1
	MessageType_mtERROR_MSG   MessageType = 2
	MessageType_mtPING        MessageType = 3
	MessageType_mtPROOFOFWORK MessageType = 4
	MessageType_mtCLUSTER     MessageType = 5
	// network presence detection
	MessageType_mtGET_CONTACTS MessageType = 10
	MessageType_mtCONTACT      MessageType = 11
	MessageType_mtGET_PEERS    MessageType = 12
	MessageType_mtPEERS        MessageType = 13
	// This field was previous used for PeerFinder ENDPOINTS messages. Since the
	// structure's required fields changed, the message number was changed.
	MessageType_mtUNUSED_FIELD MessageType = 14
	MessageType_mtENDPOINTS    MessageType = 15
	// operations for 'small' nodes
	MessageType_mtSEARCH_TRANSACTION MessageType = 20
	MessageType_mtGET_ACCOUNT        MessageType = 21
	MessageType_mtACCOUNT            MessageType = 22
	// transaction and ledger processing
	MessageType_mtTRANSACTION    MessageType = 30
	MessageType_mtGET_LEDGER     MessageType = 31
	MessageType_mtLEDGER_DATA    MessageType = 32
	MessageType_mtPROPOSE_LEDGER MessageType = 33
	MessageType_mtSTATUS_CHANGE  MessageType = 34
	MessageType_mtHAVE_SET       MessageType = 35
	// data replication and synchronization
	MessageType_mtGET_VALIDATIONS MessageType = 40
	MessageType_mtVALIDATION      MessageType = 41
	MessageType_mtGET_OBJECTS     MessageType = 42
)

var MessageType_name = map[int32]string{
	1:  "mtHELLO",
	2:  "mtERROR_MSG",
	3:  "mtPING",
	4:  "mtPROOFOFWORK",
	5:  "mtCLUSTER",
	10: "mtGET_CONTACTS",
	11: "mtCONTACT",
	12: "mtGET_PEERS",
	13: "mtPEERS",
	14: "mtUNUSED_FIELD",
	15: "mtENDPOINTS",
	20: "mtSEARCH_TRANSACTION",
	21: "mtGET_ACCOUNT",
	22: "mtACCOUNT",
	30: "mtTRANSACTION",
	31: "mtGET_LEDGER",
	32: "mtLEDGER_DATA",
	33: "mtPROPOSE_LEDGER",
	34: "mtSTATUS_CHANGE",
	35: "mtHAVE_SET",
	40: "mtGET_VALIDATIONS",
	41: "mtVALIDATION",
	42: "mtGET_OBJECTS",
}
var MessageType_value = map[string]int32{
	"mtHELLO":              1,
	"mtERROR_MSG":          2,
	"mtPING":               3,
	"mtPROOFOFWORK":        4,
	"mtCLUSTER":            5,
	"mtGET_CONTACTS":       10,
	"mtCONTACT":            11,
	"mtGET_PEERS":          12,
	"mtPEERS":              13,
	"mtUNUSED_FIELD":       14,
	"mtENDPOINTS":          15,
	"mtSEARCH_TRANSACTION": 20,
	"mtGET_ACCOUNT":        21,
	"mtACCOUNT":            22,
	"mtTRANSACTION":        30,
	"mtGET_LEDGER":         31,
	"mtLEDGER_DATA":        32,
	"mtPROPOSE_LEDGER":     33,
	"mtSTATUS_CHANGE":      34,
	"mtHAVE_SET":           35,
	"mtGET_VALIDATIONS":    40,
	"mtVALIDATION":         41,
	"mtGET_OBJECTS":        42,
}

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}
func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (x *MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageType_value, data, "MessageType")
	if err != nil {
		return err
	}
	*x = MessageType(value)
	return nil
}

type TransactionStatus int32

const (
	TransactionStatus_tsNEW             TransactionStatus = 1
	TransactionStatus_tsCURRENT         TransactionStatus = 2
	TransactionStatus_tsCOMMITED        TransactionStatus = 3
	TransactionStatus_tsREJECT_CONFLICT TransactionStatus = 4
	TransactionStatus_tsREJECT_INVALID  TransactionStatus = 5
	TransactionStatus_tsREJECT_FUNDS    TransactionStatus = 6
	TransactionStatus_tsHELD_SEQ        TransactionStatus = 7
	TransactionStatus_tsHELD_LEDGER     TransactionStatus = 8
)

var TransactionStatus_name = map[int32]string{
	1: "tsNEW",
	2: "tsCURRENT",
	3: "tsCOMMITED",
	4: "tsREJECT_CONFLICT",
	5: "tsREJECT_INVALID",
	6: "tsREJECT_FUNDS",
	7: "tsHELD_SEQ",
	8: "tsHELD_LEDGER",
}
var TransactionStatus_value = map[string]int32{
	"tsNEW":             1,
	"tsCURRENT":         2,
	"tsCOMMITED":        3,
	"tsREJECT_CONFLICT": 4,
	"tsREJECT_INVALID":  5,
	"tsREJECT_FUNDS":    6,
	"tsHELD_SEQ":        7,
	"tsHELD_LEDGER":     8,
}

func (x TransactionStatus) Enum() *TransactionStatus {
	p := new(TransactionStatus)
	*p = x
	return p
}
func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}
func (x *TransactionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionStatus_value, data, "TransactionStatus")
	if err != nil {
		return err
	}
	*x = TransactionStatus(value)
	return nil
}

type NodeStatus int32

const (
	NodeStatus_nsCONNECTING NodeStatus = 1
	NodeStatus_nsCONNECTED  NodeStatus = 2
	NodeStatus_nsMONITORING NodeStatus = 3
	NodeStatus_nsVALIDATING NodeStatus = 4
	NodeStatus_nsSHUTTING   NodeStatus = 5
)

var NodeStatus_name = map[int32]string{
	1: "nsCONNECTING",
	2: "nsCONNECTED",
	3: "nsMONITORING",
	4: "nsVALIDATING",
	5: "nsSHUTTING",
}
var NodeStatus_value = map[string]int32{
	"nsCONNECTING": 1,
	"nsCONNECTED":  2,
	"nsMONITORING": 3,
	"nsVALIDATING": 4,
	"nsSHUTTING":   5,
}

func (x NodeStatus) Enum() *NodeStatus {
	p := new(NodeStatus)
	*p = x
	return p
}
func (x NodeStatus) String() string {
	return proto.EnumName(NodeStatus_name, int32(x))
}
func (x *NodeStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NodeStatus_value, data, "NodeStatus")
	if err != nil {
		return err
	}
	*x = NodeStatus(value)
	return nil
}

type NodeEvent int32

const (
	NodeEvent_neCLOSING_LEDGER  NodeEvent = 1
	NodeEvent_neACCEPTED_LEDGER NodeEvent = 2
	NodeEvent_neSWITCHED_LEDGER NodeEvent = 3
	NodeEvent_neLOST_SYNC       NodeEvent = 4
)

var NodeEvent_name = map[int32]string{
	1: "neCLOSING_LEDGER",
	2: "neACCEPTED_LEDGER",
	3: "neSWITCHED_LEDGER",
	4: "neLOST_SYNC",
}
var NodeEvent_value = map[string]int32{
	"neCLOSING_LEDGER":  1,
	"neACCEPTED_LEDGER": 2,
	"neSWITCHED_LEDGER": 3,
	"neLOST_SYNC":       4,
}

func (x NodeEvent) Enum() *NodeEvent {
	p := new(NodeEvent)
	*p = x
	return p
}
func (x NodeEvent) String() string {
	return proto.EnumName(NodeEvent_name, int32(x))
}
func (x *NodeEvent) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NodeEvent_value, data, "NodeEvent")
	if err != nil {
		return err
	}
	*x = NodeEvent(value)
	return nil
}

type TxSetStatus int32

const (
	TxSetStatus_tsHAVE    TxSetStatus = 1
	TxSetStatus_tsCAN_GET TxSetStatus = 2
	TxSetStatus_tsNEED    TxSetStatus = 3
)

var TxSetStatus_name = map[int32]string{
	1: "tsHAVE",
	2: "tsCAN_GET",
	3: "tsNEED",
}
var TxSetStatus_value = map[string]int32{
	"tsHAVE":    1,
	"tsCAN_GET": 2,
	"tsNEED":    3,
}

func (x TxSetStatus) Enum() *TxSetStatus {
	p := new(TxSetStatus)
	*p = x
	return p
}
func (x TxSetStatus) String() string {
	return proto.EnumName(TxSetStatus_name, int32(x))
}
func (x *TxSetStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TxSetStatus_value, data, "TxSetStatus")
	if err != nil {
		return err
	}
	*x = TxSetStatus(value)
	return nil
}

type TMLedgerInfoType int32

const (
	TMLedgerInfoType_liBASE         TMLedgerInfoType = 0
	TMLedgerInfoType_liTX_NODE      TMLedgerInfoType = 1
	TMLedgerInfoType_liAS_NODE      TMLedgerInfoType = 2
	TMLedgerInfoType_liTS_CANDIDATE TMLedgerInfoType = 3
)

var TMLedgerInfoType_name = map[int32]string{
	0: "liBASE",
	1: "liTX_NODE",
	2: "liAS_NODE",
	3: "liTS_CANDIDATE",
}
var TMLedgerInfoType_value = map[string]int32{
	"liBASE":         0,
	"liTX_NODE":      1,
	"liAS_NODE":      2,
	"liTS_CANDIDATE": 3,
}

func (x TMLedgerInfoType) Enum() *TMLedgerInfoType {
	p := new(TMLedgerInfoType)
	*p = x
	return p
}
func (x TMLedgerInfoType) String() string {
	return proto.EnumName(TMLedgerInfoType_name, int32(x))
}
func (x *TMLedgerInfoType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TMLedgerInfoType_value, data, "TMLedgerInfoType")
	if err != nil {
		return err
	}
	*x = TMLedgerInfoType(value)
	return nil
}

type TMLedgerType int32

const (
	TMLedgerType_ltACCEPTED TMLedgerType = 0
	TMLedgerType_ltCURRENT  TMLedgerType = 1
	TMLedgerType_ltCLOSED   TMLedgerType = 2
)

var TMLedgerType_name = map[int32]string{
	0: "ltACCEPTED",
	1: "ltCURRENT",
	2: "ltCLOSED",
}
var TMLedgerType_value = map[string]int32{
	"ltACCEPTED": 0,
	"ltCURRENT":  1,
	"ltCLOSED":   2,
}

func (x TMLedgerType) Enum() *TMLedgerType {
	p := new(TMLedgerType)
	*p = x
	return p
}
func (x TMLedgerType) String() string {
	return proto.EnumName(TMLedgerType_name, int32(x))
}
func (x *TMLedgerType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TMLedgerType_value, data, "TMLedgerType")
	if err != nil {
		return err
	}
	*x = TMLedgerType(value)
	return nil
}

type TMQueryType int32

const (
	TMQueryType_qtINDIRECT TMQueryType = 0
)

var TMQueryType_name = map[int32]string{
	0: "qtINDIRECT",
}
var TMQueryType_value = map[string]int32{
	"qtINDIRECT": 0,
}

func (x TMQueryType) Enum() *TMQueryType {
	p := new(TMQueryType)
	*p = x
	return p
}
func (x TMQueryType) String() string {
	return proto.EnumName(TMQueryType_name, int32(x))
}
func (x *TMQueryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TMQueryType_value, data, "TMQueryType")
	if err != nil {
		return err
	}
	*x = TMQueryType(value)
	return nil
}

type TMReplyError int32

const (
	TMReplyError_reNO_LEDGER TMReplyError = 1
	TMReplyError_reNO_NODE   TMReplyError = 2
)

var TMReplyError_name = map[int32]string{
	1: "reNO_LEDGER",
	2: "reNO_NODE",
}
var TMReplyError_value = map[string]int32{
	"reNO_LEDGER": 1,
	"reNO_NODE":   2,
}

func (x TMReplyError) Enum() *TMReplyError {
	p := new(TMReplyError)
	*p = x
	return p
}
func (x TMReplyError) String() string {
	return proto.EnumName(TMReplyError_name, int32(x))
}
func (x *TMReplyError) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TMReplyError_value, data, "TMReplyError")
	if err != nil {
		return err
	}
	*x = TMReplyError(value)
	return nil
}

type TMProofWork_PowResult int32

const (
	TMProofWork_powrOK         TMProofWork_PowResult = 0
	TMProofWork_powrREUSED     TMProofWork_PowResult = 1
	TMProofWork_powrEXPIRED    TMProofWork_PowResult = 2
	TMProofWork_powrTOOEASY    TMProofWork_PowResult = 3
	TMProofWork_powrINVALID    TMProofWork_PowResult = 4
	TMProofWork_powrDISCONNECT TMProofWork_PowResult = 5
)

var TMProofWork_PowResult_name = map[int32]string{
	0: "powrOK",
	1: "powrREUSED",
	2: "powrEXPIRED",
	3: "powrTOOEASY",
	4: "powrINVALID",
	5: "powrDISCONNECT",
}
var TMProofWork_PowResult_value = map[string]int32{
	"powrOK":         0,
	"powrREUSED":     1,
	"powrEXPIRED":    2,
	"powrTOOEASY":    3,
	"powrINVALID":    4,
	"powrDISCONNECT": 5,
}

func (x TMProofWork_PowResult) Enum() *TMProofWork_PowResult {
	p := new(TMProofWork_PowResult)
	*p = x
	return p
}
func (x TMProofWork_PowResult) String() string {
	return proto.EnumName(TMProofWork_PowResult_name, int32(x))
}
func (x *TMProofWork_PowResult) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TMProofWork_PowResult_value, data, "TMProofWork_PowResult")
	if err != nil {
		return err
	}
	*x = TMProofWork_PowResult(value)
	return nil
}

type TMGetObjectByHash_ObjectType int32

const (
	TMGetObjectByHash_otUNKNOWN          TMGetObjectByHash_ObjectType = 0
	TMGetObjectByHash_otLEDGER           TMGetObjectByHash_ObjectType = 1
	TMGetObjectByHash_otTRANSACTION      TMGetObjectByHash_ObjectType = 2
	TMGetObjectByHash_otTRANSACTION_NODE TMGetObjectByHash_ObjectType = 3
	TMGetObjectByHash_otSTATE_NODE       TMGetObjectByHash_ObjectType = 4
	TMGetObjectByHash_otCAS_OBJECT       TMGetObjectByHash_ObjectType = 5
	TMGetObjectByHash_otFETCH_PACK       TMGetObjectByHash_ObjectType = 6
)

var TMGetObjectByHash_ObjectType_name = map[int32]string{
	0: "otUNKNOWN",
	1: "otLEDGER",
	2: "otTRANSACTION",
	3: "otTRANSACTION_NODE",
	4: "otSTATE_NODE",
	5: "otCAS_OBJECT",
	6: "otFETCH_PACK",
}
var TMGetObjectByHash_ObjectType_value = map[string]int32{
	"otUNKNOWN":          0,
	"otLEDGER":           1,
	"otTRANSACTION":      2,
	"otTRANSACTION_NODE": 3,
	"otSTATE_NODE":       4,
	"otCAS_OBJECT":       5,
	"otFETCH_PACK":       6,
}

func (x TMGetObjectByHash_ObjectType) Enum() *TMGetObjectByHash_ObjectType {
	p := new(TMGetObjectByHash_ObjectType)
	*p = x
	return p
}
func (x TMGetObjectByHash_ObjectType) String() string {
	return proto.EnumName(TMGetObjectByHash_ObjectType_name, int32(x))
}
func (x *TMGetObjectByHash_ObjectType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TMGetObjectByHash_ObjectType_value, data, "TMGetObjectByHash_ObjectType")
	if err != nil {
		return err
	}
	*x = TMGetObjectByHash_ObjectType(value)
	return nil
}

type TMPingPingType int32

const (
	TMPing_ptPING TMPingPingType = 0
	TMPing_ptPONG TMPingPingType = 1
)

var TMPingPingType_name = map[int32]string{
	0: "ptPING",
	1: "ptPONG",
}
var TMPingPingType_value = map[string]int32{
	"ptPING": 0,
	"ptPONG": 1,
}

func (x TMPingPingType) Enum() *TMPingPingType {
	p := new(TMPingPingType)
	*p = x
	return p
}
func (x TMPingPingType) String() string {
	return proto.EnumName(TMPingPingType_name, int32(x))
}
func (x *TMPingPingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TMPingPingType_value, data, "TMPingPingType")
	if err != nil {
		return err
	}
	*x = TMPingPingType(value)
	return nil
}

type TMProofWork struct {
	Token            *string                `protobuf:"bytes,1,req,name=token" json:"token,omitempty"`
	Iterations       *uint32                `protobuf:"varint,2,opt,name=iterations" json:"iterations,omitempty"`
	Target           []byte                 `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	Challenge        []byte                 `protobuf:"bytes,4,opt,name=challenge" json:"challenge,omitempty"`
	Response         []byte                 `protobuf:"bytes,5,opt,name=response" json:"response,omitempty"`
	Result           *TMProofWork_PowResult `protobuf:"varint,6,opt,name=result,enum=protocol.TMProofWork_PowResult" json:"result,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *TMProofWork) Reset()         { *m = TMProofWork{} }
func (m *TMProofWork) String() string { return proto.CompactTextString(m) }
func (*TMProofWork) ProtoMessage()    {}

func (m *TMProofWork) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *TMProofWork) GetIterations() uint32 {
	if m != nil && m.Iterations != nil {
		return *m.Iterations
	}
	return 0
}

func (m *TMProofWork) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *TMProofWork) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

func (m *TMProofWork) GetResponse() []byte {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *TMProofWork) GetResult() TMProofWork_PowResult {
	if m != nil && m.Result != nil {
		return *m.Result
	}
	return TMProofWork_powrOK
}

// Sent on connect
type TMHello struct {
	// VFALCO NOTE The major and minor parts of the version number are
	//             encoded in the high and low order 16 bits of the uint32.
	//
	ProtoVersion     *uint32      `protobuf:"varint,1,req,name=protoVersion" json:"protoVersion,omitempty"`
	ProtoVersionMin  *uint32      `protobuf:"varint,2,req,name=protoVersionMin" json:"protoVersionMin,omitempty"`
	NodePublic       []byte       `protobuf:"bytes,3,req,name=nodePublic" json:"nodePublic,omitempty"`
	NodeProof        []byte       `protobuf:"bytes,4,req,name=nodeProof" json:"nodeProof,omitempty"`
	FullVersion      *string      `protobuf:"bytes,5,opt,name=fullVersion" json:"fullVersion,omitempty"`
	NetTime          *uint64      `protobuf:"varint,6,opt,name=netTime" json:"netTime,omitempty"`
	Ipv4Port         *uint32      `protobuf:"varint,7,opt,name=ipv4Port" json:"ipv4Port,omitempty"`
	LedgerIndex      *uint32      `protobuf:"varint,8,opt,name=ledgerIndex" json:"ledgerIndex,omitempty"`
	LedgerClosed     []byte       `protobuf:"bytes,9,opt,name=ledgerClosed" json:"ledgerClosed,omitempty"`
	LedgerPrevious   []byte       `protobuf:"bytes,10,opt,name=ledgerPrevious" json:"ledgerPrevious,omitempty"`
	NodePrivate      *bool        `protobuf:"varint,11,opt,name=nodePrivate" json:"nodePrivate,omitempty"`
	ProofOfWork      *TMProofWork `protobuf:"bytes,12,opt,name=proofOfWork" json:"proofOfWork,omitempty"`
	TestNet          *bool        `protobuf:"varint,13,opt,name=testNet" json:"testNet,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TMHello) Reset()         { *m = TMHello{} }
func (m *TMHello) String() string { return proto.CompactTextString(m) }
func (*TMHello) ProtoMessage()    {}

func (m *TMHello) GetProtoVersion() uint32 {
	if m != nil && m.ProtoVersion != nil {
		return *m.ProtoVersion
	}
	return 0
}

func (m *TMHello) GetProtoVersionMin() uint32 {
	if m != nil && m.ProtoVersionMin != nil {
		return *m.ProtoVersionMin
	}
	return 0
}

func (m *TMHello) GetNodePublic() []byte {
	if m != nil {
		return m.NodePublic
	}
	return nil
}

func (m *TMHello) GetNodeProof() []byte {
	if m != nil {
		return m.NodeProof
	}
	return nil
}

func (m *TMHello) GetFullVersion() string {
	if m != nil && m.FullVersion != nil {
		return *m.FullVersion
	}
	return ""
}

func (m *TMHello) GetNetTime() uint64 {
	if m != nil && m.NetTime != nil {
		return *m.NetTime
	}
	return 0
}

func (m *TMHello) GetIpv4Port() uint32 {
	if m != nil && m.Ipv4Port != nil {
		return *m.Ipv4Port
	}
	return 0
}

func (m *TMHello) GetLedgerIndex() uint32 {
	if m != nil && m.LedgerIndex != nil {
		return *m.LedgerIndex
	}
	return 0
}

func (m *TMHello) GetLedgerClosed() []byte {
	if m != nil {
		return m.LedgerClosed
	}
	return nil
}

func (m *TMHello) GetLedgerPrevious() []byte {
	if m != nil {
		return m.LedgerPrevious
	}
	return nil
}

func (m *TMHello) GetNodePrivate() bool {
	if m != nil && m.NodePrivate != nil {
		return *m.NodePrivate
	}
	return false
}

func (m *TMHello) GetProofOfWork() *TMProofWork {
	if m != nil {
		return m.ProofOfWork
	}
	return nil
}

func (m *TMHello) GetTestNet() bool {
	if m != nil && m.TestNet != nil {
		return *m.TestNet
	}
	return false
}

// The status of a node in our cluster
type TMClusterNode struct {
	PublicKey        *string `protobuf:"bytes,1,req,name=publicKey" json:"publicKey,omitempty"`
	ReportTime       *uint32 `protobuf:"varint,2,req,name=reportTime" json:"reportTime,omitempty"`
	NodeLoad         *uint32 `protobuf:"varint,3,req,name=nodeLoad" json:"nodeLoad,omitempty"`
	NodeName         *string `protobuf:"bytes,4,opt,name=nodeName" json:"nodeName,omitempty"`
	Address          *string `protobuf:"bytes,5,opt,name=address" json:"address,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TMClusterNode) Reset()         { *m = TMClusterNode{} }
func (m *TMClusterNode) String() string { return proto.CompactTextString(m) }
func (*TMClusterNode) ProtoMessage()    {}

func (m *TMClusterNode) GetPublicKey() string {
	if m != nil && m.PublicKey != nil {
		return *m.PublicKey
	}
	return ""
}

func (m *TMClusterNode) GetReportTime() uint32 {
	if m != nil && m.ReportTime != nil {
		return *m.ReportTime
	}
	return 0
}

func (m *TMClusterNode) GetNodeLoad() uint32 {
	if m != nil && m.NodeLoad != nil {
		return *m.NodeLoad
	}
	return 0
}

func (m *TMClusterNode) GetNodeName() string {
	if m != nil && m.NodeName != nil {
		return *m.NodeName
	}
	return ""
}

func (m *TMClusterNode) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

// Sources that are placing load on the server
type TMLoadSource struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Cost             *uint32 `protobuf:"varint,2,req,name=cost" json:"cost,omitempty"`
	Count            *uint32 `protobuf:"varint,3,opt,name=count" json:"count,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TMLoadSource) Reset()         { *m = TMLoadSource{} }
func (m *TMLoadSource) String() string { return proto.CompactTextString(m) }
func (*TMLoadSource) ProtoMessage()    {}

func (m *TMLoadSource) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TMLoadSource) GetCost() uint32 {
	if m != nil && m.Cost != nil {
		return *m.Cost
	}
	return 0
}

func (m *TMLoadSource) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

// The status of all nodes in the cluster
type TMCluster struct {
	ClusterNodes     []*TMClusterNode `protobuf:"bytes,1,rep,name=clusterNodes" json:"clusterNodes,omitempty"`
	LoadSources      []*TMLoadSource  `protobuf:"bytes,2,rep,name=loadSources" json:"loadSources,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *TMCluster) Reset()         { *m = TMCluster{} }
func (m *TMCluster) String() string { return proto.CompactTextString(m) }
func (*TMCluster) ProtoMessage()    {}

func (m *TMCluster) GetClusterNodes() []*TMClusterNode {
	if m != nil {
		return m.ClusterNodes
	}
	return nil
}

func (m *TMCluster) GetLoadSources() []*TMLoadSource {
	if m != nil {
		return m.LoadSources
	}
	return nil
}

type TMTransaction struct {
	RawTransaction   []byte             `protobuf:"bytes,1,req,name=rawTransaction" json:"rawTransaction,omitempty"`
	Status           *TransactionStatus `protobuf:"varint,2,req,name=status,enum=protocol.TransactionStatus" json:"status,omitempty"`
	ReceiveTimestamp *uint64            `protobuf:"varint,3,opt,name=receiveTimestamp" json:"receiveTimestamp,omitempty"`
	CheckedSignature *bool              `protobuf:"varint,4,opt,name=checkedSignature" json:"checkedSignature,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *TMTransaction) Reset()         { *m = TMTransaction{} }
func (m *TMTransaction) String() string { return proto.CompactTextString(m) }
func (*TMTransaction) ProtoMessage()    {}

func (m *TMTransaction) GetRawTransaction() []byte {
	if m != nil {
		return m.RawTransaction
	}
	return nil
}

func (m *TMTransaction) GetStatus() TransactionStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return TransactionStatus_tsNEW
}

func (m *TMTransaction) GetReceiveTimestamp() uint64 {
	if m != nil && m.ReceiveTimestamp != nil {
		return *m.ReceiveTimestamp
	}
	return 0
}

func (m *TMTransaction) GetCheckedSignature() bool {
	if m != nil && m.CheckedSignature != nil {
		return *m.CheckedSignature
	}
	return false
}

type TMStatusChange struct {
	NewStatus          *NodeStatus `protobuf:"varint,1,opt,name=newStatus,enum=protocol.NodeStatus" json:"newStatus,omitempty"`
	NewEvent           *NodeEvent  `protobuf:"varint,2,opt,name=newEvent,enum=protocol.NodeEvent" json:"newEvent,omitempty"`
	LedgerSeq          *uint32     `protobuf:"varint,3,opt,name=ledgerSeq" json:"ledgerSeq,omitempty"`
	LedgerHash         []byte      `protobuf:"bytes,4,opt,name=ledgerHash" json:"ledgerHash,omitempty"`
	LedgerHashPrevious []byte      `protobuf:"bytes,5,opt,name=ledgerHashPrevious" json:"ledgerHashPrevious,omitempty"`
	NetworkTime        *uint64     `protobuf:"varint,6,opt,name=networkTime" json:"networkTime,omitempty"`
	FirstSeq           *uint32     `protobuf:"varint,7,opt,name=firstSeq" json:"firstSeq,omitempty"`
	LastSeq            *uint32     `protobuf:"varint,8,opt,name=lastSeq" json:"lastSeq,omitempty"`
	XXX_unrecognized   []byte      `json:"-"`
}

func (m *TMStatusChange) Reset()         { *m = TMStatusChange{} }
func (m *TMStatusChange) String() string { return proto.CompactTextString(m) }
func (*TMStatusChange) ProtoMessage()    {}

func (m *TMStatusChange) GetNewStatus() NodeStatus {
	if m != nil && m.NewStatus != nil {
		return *m.NewStatus
	}
	return NodeStatus_nsCONNECTING
}

func (m *TMStatusChange) GetNewEvent() NodeEvent {
	if m != nil && m.NewEvent != nil {
		return *m.NewEvent
	}
	return NodeEvent_neCLOSING_LEDGER
}

func (m *TMStatusChange) GetLedgerSeq() uint32 {
	if m != nil && m.LedgerSeq != nil {
		return *m.LedgerSeq
	}
	return 0
}

func (m *TMStatusChange) GetLedgerHash() []byte {
	if m != nil {
		return m.LedgerHash
	}
	return nil
}

func (m *TMStatusChange) GetLedgerHashPrevious() []byte {
	if m != nil {
		return m.LedgerHashPrevious
	}
	return nil
}

func (m *TMStatusChange) GetNetworkTime() uint64 {
	if m != nil && m.NetworkTime != nil {
		return *m.NetworkTime
	}
	return 0
}

func (m *TMStatusChange) GetFirstSeq() uint32 {
	if m != nil && m.FirstSeq != nil {
		return *m.FirstSeq
	}
	return 0
}

func (m *TMStatusChange) GetLastSeq() uint32 {
	if m != nil && m.LastSeq != nil {
		return *m.LastSeq
	}
	return 0
}

// Announce to the network our position on a closing ledger
type TMProposeSet struct {
	ProposeSeq          *uint32  `protobuf:"varint,1,req,name=proposeSeq" json:"proposeSeq,omitempty"`
	CurrentTxHash       []byte   `protobuf:"bytes,2,req,name=currentTxHash" json:"currentTxHash,omitempty"`
	NodePubKey          []byte   `protobuf:"bytes,3,req,name=nodePubKey" json:"nodePubKey,omitempty"`
	CloseTime           *uint32  `protobuf:"varint,4,req,name=closeTime" json:"closeTime,omitempty"`
	Signature           []byte   `protobuf:"bytes,5,req,name=signature" json:"signature,omitempty"`
	Previousledger      []byte   `protobuf:"bytes,6,opt,name=previousledger" json:"previousledger,omitempty"`
	CheckedSignature    *bool    `protobuf:"varint,7,opt,name=checkedSignature" json:"checkedSignature,omitempty"`
	AddedTransactions   [][]byte `protobuf:"bytes,10,rep,name=addedTransactions" json:"addedTransactions,omitempty"`
	RemovedTransactions [][]byte `protobuf:"bytes,11,rep,name=removedTransactions" json:"removedTransactions,omitempty"`
	XXX_unrecognized    []byte   `json:"-"`
}

func (m *TMProposeSet) Reset()         { *m = TMProposeSet{} }
func (m *TMProposeSet) String() string { return proto.CompactTextString(m) }
func (*TMProposeSet) ProtoMessage()    {}

func (m *TMProposeSet) GetProposeSeq() uint32 {
	if m != nil && m.ProposeSeq != nil {
		return *m.ProposeSeq
	}
	return 0
}

func (m *TMProposeSet) GetCurrentTxHash() []byte {
	if m != nil {
		return m.CurrentTxHash
	}
	return nil
}

func (m *TMProposeSet) GetNodePubKey() []byte {
	if m != nil {
		return m.NodePubKey
	}
	return nil
}

func (m *TMProposeSet) GetCloseTime() uint32 {
	if m != nil && m.CloseTime != nil {
		return *m.CloseTime
	}
	return 0
}

func (m *TMProposeSet) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *TMProposeSet) GetPreviousledger() []byte {
	if m != nil {
		return m.Previousledger
	}
	return nil
}

func (m *TMProposeSet) GetCheckedSignature() bool {
	if m != nil && m.CheckedSignature != nil {
		return *m.CheckedSignature
	}
	return false
}

func (m *TMProposeSet) GetAddedTransactions() [][]byte {
	if m != nil {
		return m.AddedTransactions
	}
	return nil
}

func (m *TMProposeSet) GetRemovedTransactions() [][]byte {
	if m != nil {
		return m.RemovedTransactions
	}
	return nil
}

type TMHaveTransactionSet struct {
	Status           *TxSetStatus `protobuf:"varint,1,req,name=status,enum=protocol.TxSetStatus" json:"status,omitempty"`
	Hash             []byte       `protobuf:"bytes,2,req,name=hash" json:"hash,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TMHaveTransactionSet) Reset()         { *m = TMHaveTransactionSet{} }
func (m *TMHaveTransactionSet) String() string { return proto.CompactTextString(m) }
func (*TMHaveTransactionSet) ProtoMessage()    {}

func (m *TMHaveTransactionSet) GetStatus() TxSetStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return TxSetStatus_tsHAVE
}

func (m *TMHaveTransactionSet) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// Used to sign a final closed ledger after reprocessing
type TMValidation struct {
	Validation       []byte `protobuf:"bytes,1,req,name=validation" json:"validation,omitempty"`
	CheckedSignature *bool  `protobuf:"varint,2,opt,name=checkedSignature" json:"checkedSignature,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TMValidation) Reset()         { *m = TMValidation{} }
func (m *TMValidation) String() string { return proto.CompactTextString(m) }
func (*TMValidation) ProtoMessage()    {}

func (m *TMValidation) GetValidation() []byte {
	if m != nil {
		return m.Validation
	}
	return nil
}

func (m *TMValidation) GetCheckedSignature() bool {
	if m != nil && m.CheckedSignature != nil {
		return *m.CheckedSignature
	}
	return false
}

type TMGetValidations struct {
	LedgerIndex      *uint32  `protobuf:"varint,1,req,name=ledgerIndex" json:"ledgerIndex,omitempty"`
	Hanko            [][]byte `protobuf:"bytes,2,rep,name=hanko" json:"hanko,omitempty"`
	Count            *uint32  `protobuf:"varint,3,opt,name=count" json:"count,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TMGetValidations) Reset()         { *m = TMGetValidations{} }
func (m *TMGetValidations) String() string { return proto.CompactTextString(m) }
func (*TMGetValidations) ProtoMessage()    {}

func (m *TMGetValidations) GetLedgerIndex() uint32 {
	if m != nil && m.LedgerIndex != nil {
		return *m.LedgerIndex
	}
	return 0
}

func (m *TMGetValidations) GetHanko() [][]byte {
	if m != nil {
		return m.Hanko
	}
	return nil
}

func (m *TMGetValidations) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

type TMContact struct {
	PubKey           []byte   `protobuf:"bytes,1,req,name=pubKey" json:"pubKey,omitempty"`
	SoftwareVersion  *uint32  `protobuf:"varint,2,req,name=softwareVersion" json:"softwareVersion,omitempty"`
	ProtoVersion     *uint32  `protobuf:"varint,3,req,name=protoVersion" json:"protoVersion,omitempty"`
	NodeFlags        *uint64  `protobuf:"varint,4,req,name=nodeFlags" json:"nodeFlags,omitempty"`
	Timestamp        *uint64  `protobuf:"varint,5,req,name=timestamp" json:"timestamp,omitempty"`
	NodeInfo         [][]byte `protobuf:"bytes,6,rep,name=nodeInfo" json:"nodeInfo,omitempty"`
	Signature        []byte   `protobuf:"bytes,7,req,name=signature" json:"signature,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TMContact) Reset()         { *m = TMContact{} }
func (m *TMContact) String() string { return proto.CompactTextString(m) }
func (*TMContact) ProtoMessage()    {}

func (m *TMContact) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *TMContact) GetSoftwareVersion() uint32 {
	if m != nil && m.SoftwareVersion != nil {
		return *m.SoftwareVersion
	}
	return 0
}

func (m *TMContact) GetProtoVersion() uint32 {
	if m != nil && m.ProtoVersion != nil {
		return *m.ProtoVersion
	}
	return 0
}

func (m *TMContact) GetNodeFlags() uint64 {
	if m != nil && m.NodeFlags != nil {
		return *m.NodeFlags
	}
	return 0
}

func (m *TMContact) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *TMContact) GetNodeInfo() [][]byte {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

func (m *TMContact) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// request node information
type TMGetContacts struct {
	NodeIDs          [][]byte `protobuf:"bytes,1,rep,name=nodeIDs" json:"nodeIDs,omitempty"`
	NodeCount        *uint32  `protobuf:"varint,2,opt,name=nodeCount" json:"nodeCount,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TMGetContacts) Reset()         { *m = TMGetContacts{} }
func (m *TMGetContacts) String() string { return proto.CompactTextString(m) }
func (*TMGetContacts) ProtoMessage()    {}

func (m *TMGetContacts) GetNodeIDs() [][]byte {
	if m != nil {
		return m.NodeIDs
	}
	return nil
}

func (m *TMGetContacts) GetNodeCount() uint32 {
	if m != nil && m.NodeCount != nil {
		return *m.NodeCount
	}
	return 0
}

type TMGetPeers struct {
	DoWeNeedThis     *uint32 `protobuf:"varint,1,req,name=doWeNeedThis" json:"doWeNeedThis,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TMGetPeers) Reset()         { *m = TMGetPeers{} }
func (m *TMGetPeers) String() string { return proto.CompactTextString(m) }
func (*TMGetPeers) ProtoMessage()    {}

func (m *TMGetPeers) GetDoWeNeedThis() uint32 {
	if m != nil && m.DoWeNeedThis != nil {
		return *m.DoWeNeedThis
	}
	return 0
}

type TMIPv4Endpoint struct {
	Ipv4 *uint32 `protobuf:"varint,1,req,name=ipv4" json:"ipv4,omitempty"`
	// VFALCO NOTE There is no uint16 in google protocol buffers,
	//             so we use a uint32 to represent the port.
	//
	Ipv4Port         *uint32 `protobuf:"varint,2,req,name=ipv4Port" json:"ipv4Port,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TMIPv4Endpoint) Reset()         { *m = TMIPv4Endpoint{} }
func (m *TMIPv4Endpoint) String() string { return proto.CompactTextString(m) }
func (*TMIPv4Endpoint) ProtoMessage()    {}

func (m *TMIPv4Endpoint) GetIpv4() uint32 {
	if m != nil && m.Ipv4 != nil {
		return *m.Ipv4
	}
	return 0
}

func (m *TMIPv4Endpoint) GetIpv4Port() uint32 {
	if m != nil && m.Ipv4Port != nil {
		return *m.Ipv4Port
	}
	return 0
}

type TMPeers struct {
	Nodes            []*TMIPv4Endpoint `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *TMPeers) Reset()         { *m = TMPeers{} }
func (m *TMPeers) String() string { return proto.CompactTextString(m) }
func (*TMPeers) ProtoMessage()    {}

func (m *TMPeers) GetNodes() []*TMIPv4Endpoint {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// An Endpoint describes a network peer that can accept incoming connections
type TMEndpoint struct {
	Ipv4             *TMIPv4Endpoint `protobuf:"bytes,1,req,name=ipv4" json:"ipv4,omitempty"`
	Hops             *uint32         `protobuf:"varint,2,req,name=hops" json:"hops,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *TMEndpoint) Reset()         { *m = TMEndpoint{} }
func (m *TMEndpoint) String() string { return proto.CompactTextString(m) }
func (*TMEndpoint) ProtoMessage()    {}

func (m *TMEndpoint) GetIpv4() *TMIPv4Endpoint {
	if m != nil {
		return m.Ipv4
	}
	return nil
}

func (m *TMEndpoint) GetHops() uint32 {
	if m != nil && m.Hops != nil {
		return *m.Hops
	}
	return 0
}

// An array of Endpoint messages
type TMEndpoints struct {
	// This field is used to allow the TMEndpoints message format to be
	// modified as necessary in the future.
	Version          *uint32       `protobuf:"varint,1,req,name=version" json:"version,omitempty"`
	Endpoints        []*TMEndpoint `protobuf:"bytes,2,rep,name=endpoints" json:"endpoints,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *TMEndpoints) Reset()         { *m = TMEndpoints{} }
func (m *TMEndpoints) String() string { return proto.CompactTextString(m) }
func (*TMEndpoints) ProtoMessage()    {}

func (m *TMEndpoints) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *TMEndpoints) GetEndpoints() []*TMEndpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

type TMSearchTransaction struct {
	MaxTrans         *uint32  `protobuf:"varint,1,req,name=maxTrans" json:"maxTrans,omitempty"`
	ToAccount        []byte   `protobuf:"bytes,2,opt,name=toAccount" json:"toAccount,omitempty"`
	FromAccount      []byte   `protobuf:"bytes,3,opt,name=fromAccount" json:"fromAccount,omitempty"`
	MinLedger        *uint32  `protobuf:"varint,4,opt,name=minLedger" json:"minLedger,omitempty"`
	FromAcctSeq      []byte   `protobuf:"bytes,5,opt,name=fromAcctSeq" json:"fromAcctSeq,omitempty"`
	TransID          [][]byte `protobuf:"bytes,6,rep,name=transID" json:"transID,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TMSearchTransaction) Reset()         { *m = TMSearchTransaction{} }
func (m *TMSearchTransaction) String() string { return proto.CompactTextString(m) }
func (*TMSearchTransaction) ProtoMessage()    {}

func (m *TMSearchTransaction) GetMaxTrans() uint32 {
	if m != nil && m.MaxTrans != nil {
		return *m.MaxTrans
	}
	return 0
}

func (m *TMSearchTransaction) GetToAccount() []byte {
	if m != nil {
		return m.ToAccount
	}
	return nil
}

func (m *TMSearchTransaction) GetFromAccount() []byte {
	if m != nil {
		return m.FromAccount
	}
	return nil
}

func (m *TMSearchTransaction) GetMinLedger() uint32 {
	if m != nil && m.MinLedger != nil {
		return *m.MinLedger
	}
	return 0
}

func (m *TMSearchTransaction) GetFromAcctSeq() []byte {
	if m != nil {
		return m.FromAcctSeq
	}
	return nil
}

func (m *TMSearchTransaction) GetTransID() [][]byte {
	if m != nil {
		return m.TransID
	}
	return nil
}

type TMGetAccount struct {
	AcctID           [][]byte `protobuf:"bytes,1,rep,name=acctID" json:"acctID,omitempty"`
	Seq              *uint32  `protobuf:"varint,2,opt,name=seq" json:"seq,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TMGetAccount) Reset()         { *m = TMGetAccount{} }
func (m *TMGetAccount) String() string { return proto.CompactTextString(m) }
func (*TMGetAccount) ProtoMessage()    {}

func (m *TMGetAccount) GetAcctID() [][]byte {
	if m != nil {
		return m.AcctID
	}
	return nil
}

func (m *TMGetAccount) GetSeq() uint32 {
	if m != nil && m.Seq != nil {
		return *m.Seq
	}
	return 0
}

type Account struct {
	AccountID        []byte  `protobuf:"bytes,1,req,name=accountID" json:"accountID,omitempty"`
	Balance          *uint64 `protobuf:"varint,2,req,name=balance" json:"balance,omitempty"`
	AccountSeq       *uint32 `protobuf:"varint,3,req,name=accountSeq" json:"accountSeq,omitempty"`
	LedgerSeq        *uint32 `protobuf:"varint,4,req,name=ledgerSeq" json:"ledgerSeq,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}

func (m *Account) GetAccountID() []byte {
	if m != nil {
		return m.AccountID
	}
	return nil
}

func (m *Account) GetBalance() uint64 {
	if m != nil && m.Balance != nil {
		return *m.Balance
	}
	return 0
}

func (m *Account) GetAccountSeq() uint32 {
	if m != nil && m.AccountSeq != nil {
		return *m.AccountSeq
	}
	return 0
}

func (m *Account) GetLedgerSeq() uint32 {
	if m != nil && m.LedgerSeq != nil {
		return *m.LedgerSeq
	}
	return 0
}

type TMAccount struct {
	Accounts         []*Account `protobuf:"bytes,1,rep,name=accounts" json:"accounts,omitempty"`
	Seq              *uint32    `protobuf:"varint,2,opt,name=seq" json:"seq,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *TMAccount) Reset()         { *m = TMAccount{} }
func (m *TMAccount) String() string { return proto.CompactTextString(m) }
func (*TMAccount) ProtoMessage()    {}

func (m *TMAccount) GetAccounts() []*Account {
	if m != nil {
		return m.Accounts
	}
	return nil
}

func (m *TMAccount) GetSeq() uint32 {
	if m != nil && m.Seq != nil {
		return *m.Seq
	}
	return 0
}

type TMIndexedObject struct {
	Hash             []byte  `protobuf:"bytes,1,opt,name=hash" json:"hash,omitempty"`
	NodeID           []byte  `protobuf:"bytes,2,opt,name=nodeID" json:"nodeID,omitempty"`
	Index            []byte  `protobuf:"bytes,3,opt,name=index" json:"index,omitempty"`
	Data             []byte  `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	LedgerSeq        *uint32 `protobuf:"varint,5,opt,name=ledgerSeq" json:"ledgerSeq,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TMIndexedObject) Reset()         { *m = TMIndexedObject{} }
func (m *TMIndexedObject) String() string { return proto.CompactTextString(m) }
func (*TMIndexedObject) ProtoMessage()    {}

func (m *TMIndexedObject) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *TMIndexedObject) GetNodeID() []byte {
	if m != nil {
		return m.NodeID
	}
	return nil
}

func (m *TMIndexedObject) GetIndex() []byte {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *TMIndexedObject) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *TMIndexedObject) GetLedgerSeq() uint32 {
	if m != nil && m.LedgerSeq != nil {
		return *m.LedgerSeq
	}
	return 0
}

type TMGetObjectByHash struct {
	Type             *TMGetObjectByHash_ObjectType `protobuf:"varint,1,req,name=type,enum=protocol.TMGetObjectByHash_ObjectType" json:"type,omitempty"`
	Query            *bool                         `protobuf:"varint,2,req,name=query" json:"query,omitempty"`
	Seq              *uint32                       `protobuf:"varint,3,opt,name=seq" json:"seq,omitempty"`
	LedgerHash       []byte                        `protobuf:"bytes,4,opt,name=ledgerHash" json:"ledgerHash,omitempty"`
	Fat              *bool                         `protobuf:"varint,5,opt,name=fat" json:"fat,omitempty"`
	Objects          []*TMIndexedObject            `protobuf:"bytes,6,rep,name=objects" json:"objects,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *TMGetObjectByHash) Reset()         { *m = TMGetObjectByHash{} }
func (m *TMGetObjectByHash) String() string { return proto.CompactTextString(m) }
func (*TMGetObjectByHash) ProtoMessage()    {}

func (m *TMGetObjectByHash) GetType() TMGetObjectByHash_ObjectType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return TMGetObjectByHash_otUNKNOWN
}

func (m *TMGetObjectByHash) GetQuery() bool {
	if m != nil && m.Query != nil {
		return *m.Query
	}
	return false
}

func (m *TMGetObjectByHash) GetSeq() uint32 {
	if m != nil && m.Seq != nil {
		return *m.Seq
	}
	return 0
}

func (m *TMGetObjectByHash) GetLedgerHash() []byte {
	if m != nil {
		return m.LedgerHash
	}
	return nil
}

func (m *TMGetObjectByHash) GetFat() bool {
	if m != nil && m.Fat != nil {
		return *m.Fat
	}
	return false
}

func (m *TMGetObjectByHash) GetObjects() []*TMIndexedObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

type TMLedgerNode struct {
	Nodedata         []byte `protobuf:"bytes,1,req,name=nodedata" json:"nodedata,omitempty"`
	Nodeid           []byte `protobuf:"bytes,2,opt,name=nodeid" json:"nodeid,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TMLedgerNode) Reset()         { *m = TMLedgerNode{} }
func (m *TMLedgerNode) String() string { return proto.CompactTextString(m) }
func (*TMLedgerNode) ProtoMessage()    {}

func (m *TMLedgerNode) GetNodedata() []byte {
	if m != nil {
		return m.Nodedata
	}
	return nil
}

func (m *TMLedgerNode) GetNodeid() []byte {
	if m != nil {
		return m.Nodeid
	}
	return nil
}

type TMGetLedger struct {
	Itype            *TMLedgerInfoType `protobuf:"varint,1,req,name=itype,enum=protocol.TMLedgerInfoType" json:"itype,omitempty"`
	Ltype            *TMLedgerType     `protobuf:"varint,2,opt,name=ltype,enum=protocol.TMLedgerType" json:"ltype,omitempty"`
	LedgerHash       []byte            `protobuf:"bytes,3,opt,name=ledgerHash" json:"ledgerHash,omitempty"`
	LedgerSeq        *uint32           `protobuf:"varint,4,opt,name=ledgerSeq" json:"ledgerSeq,omitempty"`
	NodeIDs          [][]byte          `protobuf:"bytes,5,rep,name=nodeIDs" json:"nodeIDs,omitempty"`
	RequestCookie    *uint64           `protobuf:"varint,6,opt,name=requestCookie" json:"requestCookie,omitempty"`
	QueryType        *TMQueryType      `protobuf:"varint,7,opt,name=queryType,enum=protocol.TMQueryType" json:"queryType,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *TMGetLedger) Reset()         { *m = TMGetLedger{} }
func (m *TMGetLedger) String() string { return proto.CompactTextString(m) }
func (*TMGetLedger) ProtoMessage()    {}

func (m *TMGetLedger) GetItype() TMLedgerInfoType {
	if m != nil && m.Itype != nil {
		return *m.Itype
	}
	return TMLedgerInfoType_liBASE
}

func (m *TMGetLedger) GetLtype() TMLedgerType {
	if m != nil && m.Ltype != nil {
		return *m.Ltype
	}
	return TMLedgerType_ltACCEPTED
}

func (m *TMGetLedger) GetLedgerHash() []byte {
	if m != nil {
		return m.LedgerHash
	}
	return nil
}

func (m *TMGetLedger) GetLedgerSeq() uint32 {
	if m != nil && m.LedgerSeq != nil {
		return *m.LedgerSeq
	}
	return 0
}

func (m *TMGetLedger) GetNodeIDs() [][]byte {
	if m != nil {
		return m.NodeIDs
	}
	return nil
}

func (m *TMGetLedger) GetRequestCookie() uint64 {
	if m != nil && m.RequestCookie != nil {
		return *m.RequestCookie
	}
	return 0
}

func (m *TMGetLedger) GetQueryType() TMQueryType {
	if m != nil && m.QueryType != nil {
		return *m.QueryType
	}
	return TMQueryType_qtINDIRECT
}

type TMLedgerData struct {
	LedgerHash       []byte            `protobuf:"bytes,1,req,name=ledgerHash" json:"ledgerHash,omitempty"`
	LedgerSeq        *uint32           `protobuf:"varint,2,req,name=ledgerSeq" json:"ledgerSeq,omitempty"`
	Type             *TMLedgerInfoType `protobuf:"varint,3,req,name=type,enum=protocol.TMLedgerInfoType" json:"type,omitempty"`
	Nodes            []*TMLedgerNode   `protobuf:"bytes,4,rep,name=nodes" json:"nodes,omitempty"`
	RequestCookie    *uint32           `protobuf:"varint,5,opt,name=requestCookie" json:"requestCookie,omitempty"`
	Error            *TMReplyError     `protobuf:"varint,6,opt,name=error,enum=protocol.TMReplyError" json:"error,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *TMLedgerData) Reset()         { *m = TMLedgerData{} }
func (m *TMLedgerData) String() string { return proto.CompactTextString(m) }
func (*TMLedgerData) ProtoMessage()    {}

func (m *TMLedgerData) GetLedgerHash() []byte {
	if m != nil {
		return m.LedgerHash
	}
	return nil
}

func (m *TMLedgerData) GetLedgerSeq() uint32 {
	if m != nil && m.LedgerSeq != nil {
		return *m.LedgerSeq
	}
	return 0
}

func (m *TMLedgerData) GetType() TMLedgerInfoType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return TMLedgerInfoType_liBASE
}

func (m *TMLedgerData) GetNodes() []*TMLedgerNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *TMLedgerData) GetRequestCookie() uint32 {
	if m != nil && m.RequestCookie != nil {
		return *m.RequestCookie
	}
	return 0
}

func (m *TMLedgerData) GetError() TMReplyError {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return TMReplyError_reNO_LEDGER
}

type TMPing struct {
	Type             *TMPingPingType `protobuf:"varint,1,req,name=type,enum=protocol.TMPingPingType" json:"type,omitempty"`
	Seq              *uint32         `protobuf:"varint,2,opt,name=seq" json:"seq,omitempty"`
	PingTime         *uint64         `protobuf:"varint,3,opt,name=pingTime" json:"pingTime,omitempty"`
	NetTime          *uint64         `protobuf:"varint,4,opt,name=netTime" json:"netTime,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *TMPing) Reset()         { *m = TMPing{} }
func (m *TMPing) String() string { return proto.CompactTextString(m) }
func (*TMPing) ProtoMessage()    {}

func (m *TMPing) GetType() TMPingPingType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return TMPing_ptPING
}

func (m *TMPing) GetSeq() uint32 {
	if m != nil && m.Seq != nil {
		return *m.Seq
	}
	return 0
}

func (m *TMPing) GetPingTime() uint64 {
	if m != nil && m.PingTime != nil {
		return *m.PingTime
	}
	return 0
}

func (m *TMPing) GetNetTime() uint64 {
	if m != nil && m.NetTime != nil {
		return *m.NetTime
	}
	return 0
}

type TMErrorMsg struct {
	ErrorCode        *int32  `protobuf:"varint,1,opt,name=errorCode" json:"errorCode,omitempty"`
	Message          *string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TMErrorMsg) Reset()         { *m = TMErrorMsg{} }
func (m *TMErrorMsg) String() string { return proto.CompactTextString(m) }
func (*TMErrorMsg) ProtoMessage()    {}

func (m *TMErrorMsg) GetErrorCode() int32 {
	if m != nil && m.ErrorCode != nil {
		return *m.ErrorCode
	}
	return 0
}

func (m *TMErrorMsg) GetMessage() string {
	if m != nil && m.Message != nil {
		return *m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("protocol.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("protocol.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
	proto.RegisterEnum("protocol.NodeStatus", NodeStatus_name, NodeStatus_value)
	proto.RegisterEnum("protocol.NodeEvent", NodeEvent_name, NodeEvent_value)
	proto.RegisterEnum("protocol.TxSetStatus", TxSetStatus_name, TxSetStatus_value)
	proto.RegisterEnum("protocol.TMLedgerInfoType", TMLedgerInfoType_name, TMLedgerInfoType_value)
	proto.RegisterEnum("protocol.TMLedgerType", TMLedgerType_name, TMLedgerType_value)
	proto.RegisterEnum("protocol.TMQueryType", TMQueryType_name, TMQueryType_value)
	proto.RegisterEnum("protocol.TMReplyError", TMReplyError_name, TMReplyError_value)
	proto.RegisterEnum("protocol.TMProofWork_PowResult", TMProofWork_PowResult_name, TMProofWork_PowResult_value)
	proto.RegisterEnum("protocol.TMGetObjectByHash_ObjectType", TMGetObjectByHash_ObjectType_name, TMGetObjectByHash_ObjectType_value)
	proto.RegisterEnum("protocol.TMPingPingType", TMPingPingType_name, TMPingPingType_value)
}
